using System;
using System.Collections.Generic;
using System.Xml.Serialization;

namespace ngenstrings
{
	public class LocalizedString
	{
		private string _key;
		private string _value;
		private string _table;
		private string _comment;

		/// <summary>
		/// Key is the only REQUIRED parameter.
		/// </summary>
		public string Key
		{
			get { return _key; }
			set { _key = value; }
		}
		/// <summary>
		/// (optional) default value may be specified.
		/// If it is not specified, the Key text is used as the default value
		/// </summary>
		public string @Value
		{
			get
			{
				if (String.IsNullOrEmpty(_value)) 
					return _key;
				else
					return _value;
			}
			set { _value = value; }
		}
		/// <summary>
		/// (optional) comment to the translator can be specified in some method overloads
		/// If it is not specified, the method/s where the text appears is used
		/// </summary>
		public string Comment
		{
			get
			{
				if (String.IsNullOrEmpty(_comment)) 
					return InMethodString;
				else
					return _comment;
			}
			set { _comment = value; }
		}
		/// <summary>
		/// (optional) the .strings filename where the translation will be stored.
		/// If empty, the translation will be in the default Localizable.strings file.
		/// </summary>
		[XmlIgnore]
		public string Table
		{
			get
			{
				if (String.IsNullOrEmpty(_table))
					return "";
				else 
					return _table.Trim(); // return "" if nothing specified, to get default behavior
			}
			set { _table = value; }
		}
		[Obsolete("Not supported")]
		public string Bundle {get;set;} // not used

		public List<string> InMethods = new List<string>();
		public string InMethodString 
		{
			get
			{
				var s = "";
				foreach (string item in InMethods)
				{
					s += item + ", ";
				}
				return s.Trim(',',' ');
			}
		}
		public LocalizedString ()
		{
		}

		public bool IsEmpty 
		{
			get {return String.IsNullOrEmpty(_key) && String.IsNullOrEmpty(_value); }
		}

		public override string ToString ()
		{
			return string.Format("/* {2} */\n\"{0}\" = \"{1}\";\n\n", Key, Value, Comment);
		}
		public string ToCStyleString ()
		{
			return string.Format("/* {2} */\n\"{0}\" = \"{1}\";\n\n"
								, this.EscapeCStyleText(Key)
								, this.EscapeCStyleText(Value)
								, this.EscapeCStyleComment(Comment));
		}
		public string ToPListString ()
		{
			return string.Format("\t<!-- {2} -->\n\t<key>{0}</key>\n\t<string>{1}</string>\n"
								, EscapeXmlText(Key)
								, EscapeXmlText(Value)
								, EscapeXmlComment(Comment));
		}



		public static string FileHeaderCStyleString (string assemblyName)
		{
			return String.Format("/* File generated by ngenstrings from assembly {0} on {1} */\n\n"
				, assemblyName
				, DateTime.Now.ToLongDateString() + " " + DateTime.Now.ToLongTimeString() );
		}
		private string EscapeCStyleComment (string comment)
		{
			comment = comment.Replace("/*","/ *");
			comment = comment.Replace("*/","* /");
			return comment;
		}
		private string EscapeCStyleText (string text)
		{
			text = text.Replace("\n","\\n");  // newline
			text = text.Replace("\"","\\\""); // quotes
			return text;
		}



		public static string FileHeaderXmlString (string assemblyName)
		{
			return String.Format(@"<?xml version=""1.0"" encoding=""utf-8""?>
<!DOCTYPE plist PUBLIC ""-//Apple Computer//DTD PLIST 1.0//EN"" ""http://www.apple.com/DTDs/PropertyList-1.0.dtd"">
<plist version=""1.0"">
  <dict><!-- File generated by ngenstrings from assembly {0} on {1} -->
"
				, assemblyName
				, DateTime.Now.ToLongDateString() + " " + DateTime.Now.ToLongTimeString() );
		}
		public static string FileFooterXmlString ()
		{
			return @"  </dict>
</plist>";
		}
		private string EscapeXmlComment (string comment)
		{
			comment = comment.Replace("<","&lt;");
			comment = comment.Replace(">","&gt;");
			return comment;
		}
		private string EscapeXmlText (string text)
		{
			text = text.Replace("&","&amp;");  // ampersand

			text = text.Replace("<","&lt;");  // lessthan
			text = text.Replace(">","&gt;");  // greaterthan
			return text;
		}
	}
}
